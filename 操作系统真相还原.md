# 操作系统真相还原

## 第0章 一些你可能正感到迷惑的问题

###  软件是如何访问硬件的

+ 通过IO 接口制定标准，硬件按照这个标准工作

+ 接口分为串行接口和并行接口

  `访问外部硬件有两个方式。`

1. 将某个外设的内存映射到一定范围的地址空间中，CPU 通过地址总线访问该内存区域时会落到外设 的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如 显卡，显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被 映射到主机物理内存上的低端 1MB 的 0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，往这片内存上 写字节便是往屏幕上打印内容。看上去这么高大上的做法是怎么实现的，这个我们就不关心了，前面说过，计 算机中处处是分层，我们要充分相信上一层的工作。 

2. 外设是通过 IO 接口与 CPU 通信的，CPU 访问外设，就是访问 IO 接口，由 IO 接口将信息传递 给另一端的外设，也就是说，CPU 从来不知道有这些设备的存在，它只知道自己操作的 IO 接口，你看， 处处体现着分层。

+ 访问 IO 接口本质上就是 访问这些寄存器，这些寄存器就是人们常说的端口。

### 应用程序如何与操作系统配合

> 用户态与内核态是对 CPU 来讲的，是指 CPU 运行在用户态（特权 3 级）还是内核态（特权 0 级）， 很多人误以为是对用户进程来讲的。 
>
> 用户进程陷入内核态是指：由于内部或外部中断发生，当前进程被暂时终止执行，其上下文被内核的 中断程序保存起来后，开始执行一段内核的代码。是内核的代码，不是用户程序在内核的代码，用户代码 怎么可能在内核中存在，所以“用户态与内核态”是对 CPU 来说的。
>
> 当应用程序陷入内核后，它自己已经下 CPU 了,上下文环境已 经被保存到自己的 0 特权级栈中了

### 内存访问为什么要分段

+ 早期程序运行时使用的是物理地址，编译后的代码在物理内存中起始地址相同，代码会发生冲突，相互覆盖。
+ 程序分段首先是为了重定位，重定位可以将物理地址冲突的程序挪到其他段
+ 程序分段其次可以解决早期16位寄存器访问 1MB 20位内存的烦恼，CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址+段内偏移地址”的地址后， 自动将段基址乘以 16，即左移了 4 位，然后再和 16 位的段内偏移地址相加，这下地址变成了 20 位了吧

#### 代码中为什么分为代码段、数据段？这和内存访问机制中的 段是一回事吗

+ 程序分段是为了使程序更加优美，不一定要分段
+ x86平台的处理器是必须要用分段来访问内存的，处理器使用段寄存器来指定待访问的内存段起始地址，分段是必然的，硬件寄存器指向的内存段最大为4GB
+ 一般的高级语言不允许程序要将代码自己分段，因为编译器要编译出适合此操作系统加载运行的程序。
+ cpu只负责运算，不负责数据的定义，汇编器负责分配空间并为变量编址，在程序有运算的定义的指令时需要分开处理，否则cpu读取到了数据的定义会被误解或者执行指令失败

#### 尽量把同一属性的数据放在一起，这样易于维护

1. 可以为它们赋予不同的属性。 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。真要是在运行过程中程序的下 一条指令被修改了，谁知道会产生什么样的灾难。 
2. 为了提高 CPU 内部缓存的命中率。 大伙儿知道，缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。CPU 内部有针对数据和针对指令的两种缓存机制，因此，将 数据和代码分开存储将使程序运行得更快。 
3. 节省内存。 程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代 码段共享就可以了。

#### 数据段或代码段的属性是谁给添加上的 

1. 编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的 代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的 只是将代码归类到一起而已，也就是将程序中的有关代码的多个 section 合并成一个大的 segment（这就是 我们所说的代码段），它并没有为代码段添加额外的信息.
2. 操作系统通过设置 GDT 全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属 性（包括 S 字段和 TYPE 字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的 那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。
3. CPU 中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其 理解为相当于段基址），从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若 有返回则发出异常。

> 总之，编译器、操作系统、CPU 三个配合在一起才能对程序保护，检测出指令中的违规行为。如果 GDT 中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有 CPU。

### 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别

+ 物理地址就是物理内存真正的地址，相当于内存中每个存储单元的门牌号，具有唯一性。不管在什么模式下， 不管什么虚拟地址、线性地址，CPU 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。

+ 在实模式下，“段基址+段内偏移地址”经过段部件的处理，直接输出的就是物理地址，CPU 可以直 接用此地址访问内存。

+ 而在保护模式下，“段基址+段内偏移地址”称为线性地址，此时的段基址是选择子。
+ 若没有开启地址分页功能， 此线性地址就被当作物理地址来用，可直接访问内存。若开启了分页功能，此线性地址又多了一个名字，就是 虚拟地址。

![image-20240723151358660](/home/abljiu/.config/Typora/typora-user-images/image-20240723151358660.png)

### 段重叠

![image-20240723151902139](/home/abljiu/.config/Typora/typora-user-images/image-20240723151902139.png)

### 什么是平坦模型

平坦模型是相对于多段模型来说的，所以说平坦模型指的就是一个段。比如在实模式下，访问超过 64KB 的内存，需要重新指定不同的段基址，通过这种迂回变通的方式才能达到目的。在保护模式下， 由于其是 32 位的，寻址范围便能够达到 4GB，段内偏移地址也是地址，所以也是 32 位。可见，在 32 位环境下用一个段就能够访问到硬件所支持的所有内存。

### cs、ds 这类 sreg 段寄存器，位宽是多少

每种模式下，段寄存器中值的意义是不同的，但不管其为何值，在段寄存器中所表达的都是指向的段 在哪里。在实模式下，CS、DS、ES、SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子”（Selector）， 当然，选择子也是数值，其依然为 16 位宽度。 可见，在 32 位 CPU 中，sreg 无论是工作在 16 位的实模式，还是 32 位的保护模式，用的段寄存器都 是同一组，并且在 32 位下的段选择子是 16 位宽度，排除了段寄存器在 32 位环境下是 32 位宽的可能，综 上所述，sreg 都是 16 位宽。

### BIOS 中断、DOS 中断、Linux 中断的区别

+ 如果事件来自于 CPU 内部就称为异常，即 Exception,如果事件来自于外部，也就是该事件由外部设备发出并通知了 CPU，这个事件就称为中断。
+ 计算机 启动之初，中断向量表中的中断例程是由 BIOS 建立的，它从物理内存地址 0x0000 处初始化并在中断向 量表中添加各种处理例程。

#### BIOS 为什么添加中断处理例程呢？

1. 给自己用，因为 BIOS 也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写 成中断函数，直接调用多省心。
2. 给后来的程序用，如加载器或 boot loader。它们在调用硬件资源时就不需要自己重写代码了。

#### CPU 如何访问到外设的 ROM

1. 内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）
2. 端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过 in/out 指令读写端口来访问硬件的内存。

#### Linux中断

Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了， 取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。Linux 的系统调用和 DOS 中断调用类似，不过 Linux 是通过 int 0x80 指令进入一个中断程序后再根据 eax 寄存器的值来调用不同的子功能函数的。如果在实模式下执行 int 指令，会自动去访问 中断向量表。如果在保护模式下执行 int 指令，则会自动访问中断描述符表。

### Section 和 Segment 的区别

C 程序大体上分为预处理、编译、汇编和链接 4 个阶段。预处理阶段是预处理器将高级语言中的宏展 开，去掉代码注释，为调试器添加行号等。编译阶段是将预处理后的高级语言进行词法分析、语法分析、 语义分析、优化，最后生成汇编代码。汇编阶段是将汇编代码编译成目标文件，也就是转换成了目标机器 平台上的机器指令。链接阶段是将目标文件连接成可执行文件。

section 称为节，是指在汇编源码中经由关键字 section 或 segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。 

segment 称为段，是链接器根据目标文件中属性相同的多个 section 合并后的 section 集合，这个集合 称为 segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment。

### 库函数是用户进程与内核的桥梁

1. 操作系统有自己支持、加载用户进程的规则，而 C 运行时库是针对此操作系统的规则，为了让 用户程序开发更加容易，用来支持用户进程的代码库。大家要明白，之所以我们写个程序又链接这又链接 那的，完全是因为操作系统规定这样做，人在屋檐下，不得不低头。
2. 用户进程要与 C 运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户 进程被加进了大量的运行库中的代码。 
3. C 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工 作，所以即使不包含标准库文件，链接阶段也要用到 c 运行时库。 
4. 用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用 户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上 所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整。
5. 尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。

### MBR、EBR、DBR 和 OBR 各是什么

1. MBR 是主引导记录，Master 或 Main Boot Record，它存在于整个硬盘最开始的那个扇区，即 0 盘 0 道 1 扇区，这个扇区便称为 MBR 引导扇区。

    MBR 引导扇区中的内容是：

   + 446 字节的引导程序及参数
   + 64 字节的分区表；
   + 2 字节结束标记 0x55 和 0xaa。

2. 各分区起始的扇区中存放的是操作系统引导程序—内核加载器，因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器）称为操作系统 引导记录 OBR，即 OS Boot Record，此扇区也称为 OBR 引导扇区。在 OBR 扇区的前 3 个字节存放了跳转指令， 这同样是约定，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序，从此 MBR 完成了交接工作，以后便是内核的天下了。

3. OBR 是从 DBR 遗留下来的， 要想了解 OBR，还是先从了解 DBR 开始。

   DBR 中的内容大概是：

   + 跳转指令，使 MBR 跳转到引导代码
   + 厂商信息、DOS 版本信息
   + BIOS 参数块 BPB，即 BIOS Parameter Block
   + 操作系统引导程序
   + 结束标记 0x55 和 0xaa

4. 为了解决分区数量限制的问题才有了扩展分区，EBR 是扩展分区中为了兼容 MBR 才提出的概念，主要是兼容 MBR 中的分区表。

![image-20240724112912789](/home/abljiu/.config/Typora/typora-user-images/image-20240724112912789.png)



## 第2章 编写 MBR 主引导记录，让我们开始 掌权

### 软件接力第一棒，BIOS

![image-20240724154959947](/home/abljiu/.config/Typora/typora-user-images/image-20240724154959947.png)			



###  0x7c00 

+ BIOS 最后一项工作校验启动盘中位于 0 盘 0 道 1 扇区的内容
+ 8086CPU 要求物理地址 0x0～0x3FF 存放中断向量表，所以此处不能动了，再选新的地方看看。 按 DOS 1.0 要求的最小内存 32KB 来说，MBR 希望给人家尽可能多的预留空间，这样也是保全自己 的作法，免得过早被覆盖。所以 MBR 只能放在 32KB 的末尾。 MBR 本身也是程序，是程序就要用到栈，栈也是在内存中的，MBR 虽然本身只有 512 字节，但还要为其 所用的栈分配点空间，所以其实际所用的内存空间要大于 512 字节，估计 1KB 内存够用了。 结合以上三点，选择32KB中的最后1KB最为合适，那此地址是多少呢？32KB换算为十六进制为0x8000， 减去 1KB(0x400)的话，等于 0x7c00。这就是倍受质疑的 0x7c00 的由来，这下清楚了。

## 第3章 完善 MBR

### CPU 的实模式

![image-20240725132513836](/home/abljiu/.config/Typora/typora-user-images/image-20240725132513836.png)

#### 通用寄存器

无论是实模式，还是保护模式，通用寄存器有 8 个，分别是 AX、BX、CX、 DX、SI、DI、BP、SP

​	

![image-20240725140928894](/home/abljiu/.config/Typora/typora-user-images/image-20240725140928894.png)

![image-20240725144417905](/home/abljiu/.config/Typora/typora-user-images/image-20240725144417905.png)
#### 实模式下内存分段由来 

CPU 中本来是没有实模式这一称呼的，是因为有了保护模式后，为了与老的模式区别开来，所以称 老的模式为实模式。

实模式的“实”体现在：程序中用到的地址都是真实的物理地址，“段基址：段内偏移”产生的逻辑 地址就是物理地址，也就是程序员看到的完全是真实的内存。

#### 实模式下 CPU 内存寻址方式

寻址方式，从大方向来看可以分为三大类：

+ 寄存器寻址
+ 立即数寻址
+ 内存寻址
  + 直接寻址
  + 基址寻址
  + 变址寻址
  + 基址变址寻址

#### 实模式下的 ret

+ ret（return）指令的功能是在栈顶（寄存器 ss：sp 所指向的地址）弹出 2 字节的内容来替换 IP 寄存器
+ retf（return far）是从栈顶取得 4 字节，栈顶处的 2 字节用来替换 IP 寄存器，另外的 2 字节用来替换 CS 寄存器。

#### 实模式下的call

+ 16 位实模式相对近调用

指令格式是 call near 立即数地址，注意啦，此形式中的操作数是立即数。其中的 near 可以省略。此 指令是个 3 字节指令，0xe8 是此操作的操作码，占 1 字节，剩下 2 字节便是操作数,操作数并不是目标函数的绝对地址，只是相对于目标函数地址的相对增量，

+ 16 位实模式间接绝对近调用

“间接”是指目标函数的地址并没有直接给出，地址要么在寄存器中，要么在内存中，总之不以立即 数的形式出现。

“绝对”是指目标函数的地址是绝对地址，不像“16 位相对近调用”中的那样是相对地址。

+ 16 位实模式直接绝对远调用

指令的一般形式是： call far 段基址（立即数）：段内偏移地址（立即数）

+ 16 位实模式间接绝对远调用

16 位间接绝对远调用指令格式是：call far 内存寻址，如 call far [bx],call far [0x1234]，操作码是 ff1e。

> 常用的是前两种

#### 实模式下的 jmp 

mp 转移指令只要更新 CS：IP 寄存器或只更新 IP 寄存器就好了，不需要保存它们的值，所以跳到新 的地址后没办法再回来，它属于“一去不回头”地去执行新指令。

+ 16 位实模式相对短转移

指令格式是 jmp short 立即数地址。例如 `jmp $`,立即数是相对地址,操作数范围是-128～127，如果操作数不在此范围，将会在编译阶段报错。

如果要将操作数范围增大，有以下两种方法

1. 将jmp 后的 short 去掉，改成 near
2.  jmp 后什么都不写，让 nasm 编译器来自动判断，用 short，还是 near。

+ 16 位实模式相对近转移

指令格式是 jmp near 立即数地址，其操作码是 0xe9。指令中的立即数地址也要经过编译器转换为地址偏移量，再变成机器指令中的操作数。

+ 16 位实模式间接绝对近转移

指令格式是 jmp near 寄存器寻址，或者 jmp near 内存寻址。

+ 16 位实模式直接绝对远转移

指令的一般形式是： jmp far 段基址（立即数）：段内偏移地址（立即数）

+ 16 位实模式间接绝对远转移

指令格式是：jmp far 内存寻址。

> 以上均属于无条件转移

#### 标志寄存器 flags 

有条件转移的条件储存在 flags寄存器中

> 实模式下标志寄存器是 16 位的 flags，在 32 位保护模式下，扩展（extend）了标志寄存器，成为 32 位的 eflags。

flags 寄存器中存储的信息，只是结果 的特征，即标志，并不是真正的结果，结果可以存储在内存中。

![image-20240726114738747](/home/abljiu/.config/Typora/typora-user-images/image-20240726114738747.png)

+ 第 0 位的是 CF 位，即 Carry Flag，意为进位。运算中，数值的最高位有可能是进位，也有可能是借 位，所以 carry 表示这两种状态。不管最高位是进位，还是借位，CF 位都会置 1，否则为 0。它可用于检 测无符号数加减法是否有溢出，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。 

+ 再说点没用的，第 1、3、5、15 位没有专门的标志位，空着占位用。 

+ 第 2 位为 PF 位，即 Parity Flag，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位 为 1，否则为 0。注意啦，是最低的那 8 位，不管操作数是 16 位，还是 32 位。奇偶校验经常用于数据传 输开始时和结束后的对比，判断传输过程中是否出现错误。 

+ 第 4 位为 AF 位，即 Auxiliary carry Flag，意为辅助进位标志，用来记录运算结果低 4 位的进、借位 情况，即若低半字节有进、借位，AF 为 1，否则为 0。 

+ 第 6 位为 ZF 位，即 Zero Flag，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。 

+ 第 7 位为 SF 位，即 Sign Flag，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。

+ 第8 位为 TF 位，即 Trap Flag，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为 0，则为连续工作的方式。平时我们用的 debug 程序，在单步调试时，原理上就是让 TF 位为 1。可见，软 件上的很多功能，必须有硬件的原生支持才能得以实现。

+  第 9 位为 IF 位，即 Interrupt Flag，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外 部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常 还是要响应的，因为它关不住。 

+ 第 10 位为 DF 位，即 Direction Flag，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为 1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个 单位，意即给地址的变化提供个方向。其中提到的这个单位的大小，取决于用什么指令。 

+ 第 11 位为 OF 位，即 Overflow Flag，意为溢出标志位。用来标识计算的结果是否超过了数据类型可 表示的范围，若超出了范围，就像水从锅里溢出去了一样。若 OF 为 1，表示有溢出，为 0 则未发生溢出。 专门用于检测有符号数运算结果是否有溢出现象。 以下标志位仅在 80286 以上 CPU 中有效。相对于 8088，它支持特权级和多任务。 

+ 第 12～13 位为 IOPL，即 Input Output Privilege Level，这用在有特权级概念的 CPU 中。有 4 个任务 特权级，即特权级 0、特权级 1、特权级 2 和特权级 3。故 IOPL 要占用 2 位来表示这 4 种特权级。如果您 对此感到迷茫，不用担心，这些将来咱们在保护模式下也得实践。 

+ 第 14 位为 NT，即 Nest Task，意为任务嵌套标志位。8088 支持多任务，一个任务就是一个进程。当 一个任务中又嵌套调用了另一个任务（进程）时，此 NT 位为 1，否则为 0。 

  > 以下标志位仅用于 80386 以上的 CPU。

+ 第 16 位为 RF 位，即 Resume Flag，意即恢复标志位。该标志位用于程序调试，指示是否接受调试故 障，它需要与调试寄存器一起使用。当 RF 为 1 时忽略调试故障，为 0 时接受。 

+ 第 17 位为 VM 位，即 Virtual 8086 Model，意为虚拟 8086 模式。这是实模式向保护模式过渡时的产物，现 在已经没有了。CPU 有了保护模式后，功能更加强大了，但为了兼容实模式下的用户程序，允许将此位置为 1， 这样便可以在保护模式下运行实模式下的程序了。实模式下的程序不支持多任务，而且程序中的地址就是真实的 物理地址。所以在保护模式下每运行一个实模式下的程序，就要为其虚拟一个实模式环境，故称为虚拟模式。 以下标志位仅用于 80486 以上的 CPU。 

+ 第 18 位为 AC 位，即 Alignment Check，意为对齐检查。什么是对齐呢？是指程序中的数据或指令其 内存地址是否是偶数，是否是 16、32 的整数倍，没有余数，这样硬件每次对地址以自增地方式（每次自 加 2、16、32 等）访问内存时，自增后的地址正好对齐数据所在的起始地址上，这就是对齐的原理。对齐 并不是软件逻辑中的要求，而是硬件上的偏好，如果待访问的内存地址是 16 或 32 的整数倍，硬件上好处 理，所以运行较快。若 AC 位为 1 时，则进行地址对齐检查，为 0 时不检查。 以下标志位只对 80586（奔腾）以上 CPU 有效。

+  第 19 位为 VIF 位，即 Virtual Interrupt Flag，意为虚拟中断标志位，虚拟模式下的中断标志。

+  第 20 位为 VIP 位，即 Virtual Interrupt Pending，意为虚拟中断挂起标志位。在多任务情况下，为操作 系统提供的虚拟中断挂起信息，需要与 VIF 位配合。 

+ 第 21 位为 ID 位，即 Identification，意思为识别标志位。系统经常要判断 CPU 型号，若 ID 为 1，表示当前 CPU 支持 CPU id 指令，这样便能获取 CPU 的型号、厂商等信息。若 ID 为 0，则表示当前 CPU 不 支持 CPU id 指令。 

+ 其余剩下的 22～31 位都没有实际用途，纯粹是占位用，为了将来扩展。

#### 有条件转移

有条件转移不是简单的一个指令，它是一个指令族，我们在此简单称 jxx。

 其格式为 jxx 目标地址。若条件满足则跳转到目标地址，否则顺序执行下一条指令。 其中，目标地址只能是段内偏移地址。在实模式下，由编译器根据当前指令与目标地址的偏移量，自 行将其编译成短转移或近转移。在保护模式下，寄存器中宽度已经到了 32 位，32 位的偏移地址可以访问 到整个 32 位地线总线的 4GB 内存空间，编译器不再区分转移方式。

#### 实模式小结

实模式被保护模式淘汰的原因，最主要是安全隐患。 在实模式下，用户程序和操作系统可以说是同一特权的程序，因为实模式下没有特权级，它处处和操 作系统平起平坐，所以可以执行一些具有破坏性的指令。 程序可以随意修改自己的段基址，这样便在 1MB 的内存空间内不受阻拦，可以随意访问任意物理内存， 包括访问操作系统所在的内存数据。

### 让我们直接对显示器说点什么吧

#### CPU 如何与外设通信—IO 接口

在 CPU 和外设之间的这一层就是 IO 接口，处理外设与CPU不兼容的问题。

IO 接口的功能：

1. 设置数据缓冲，解决 CPU 与外设的速度不匹配
2. 设置信号电平转换电路
3. 设置数据格式转换
4. 设置时序控制电路来同步 CPU 和外部设备
5. 提供地址译码（CPU 同多个硬件打交道，每个硬件要反馈的信息很多，所以一个 IO 接口必须包含多个端口，即 IO 接口上的寄存器，来存储这些信息内容。但同一时刻，只能有一个端口和 CPU 数据交换，这就需要 IO 接 口提供地址译码电路，使 CPU 可以选中某个端口，使其可以访问数据总线）

南桥芯片：仲裁 IO 接口的竞争，还要连接各种内部总线。由于它的使命，它的名字就叫做输入输出控制中心 （I/O control hub，ICH），也就是南桥芯片。

![image-20240726181545062](/home/abljiu/.config/Typora/typora-user-images/image-20240726181545062.png)



in 指令用于从端口中读取数据，其一般形式是： 

+ in al, dx
+ +in ax, dx

 其中 al 和 ax 用来存储从端口获取的数据，dx 是指端口号。 这是固定用法，只要用 in 指令，源操作数（端口号）必须是 dx，而目的操作数是用 al，还是 ax，取 决于 dx 端口指代的寄存器是 8 位宽度，还是 16 位宽度。

out 指令用于往端口中写数据，其一般形式是： 

+ out dx, al
+ out dx,ax
+ out 立即数, al
+ out 立即数, ax

注意啦，这和 in 指令相反，in 指令的源操作数是端口号，而 out 指令中的目的操作数是端口号。

#### 显卡概述 

显卡也称为显示适配器，不过归 根结底它就是 IO 接口，专门用来连接 CPU 和显示器。我们想操作显示器，没有直接的办法，只能通过它 的 IO 接口—显卡。显卡的工作就是不断地读取显存，随后将其内容发送到显示器。

#### 显存、显卡、显示器 

![image-20240726193125899](/home/abljiu/.config/Typora/typora-user-images/image-20240726193125899.png)

### 硬盘介绍



#### 硬盘控制器端口

端口可以被分为两组，Command Block registers 和 Control Block registers。Command Block registers 用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态，Control Block registers 用于控制硬盘工作状态。

![image-20240727153212079](/home/abljiu/.config/Typora/typora-user-images/image-20240727153212079.png)



device 寄存器是个杂项，很多设置都需集中在此寄存器中了，其中的第 4 位，便是指定通道上的主或从硬 盘，0 为主盘，1 为从盘。在此寄存器的低 4 位用来存储 LBA 地址 的第 24～27 位。结合上面的三个 LBA 寄存器。第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代 表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。另外的两位： 第 5 位和第 7 位是固定为 1 的，称为 MBS 位，

data 寄存器作用是读取或写入数据，在读硬盘时，硬盘准备好的数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，我们要把数据源源不断地输送到此端口， 数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。

在读硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 Status，它是 8 位宽度的寄存器，用来给出硬盘的 状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错了，具体原因可见 error 寄存器。第 3 位是 data request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机现在可以把数据读出来。第 6 位是 DRDY， 表示硬盘就绪，此位是在对硬盘诊断时用的，表示硬盘检测正常，可以继续执行一些命令。第 7 位是 BSY 位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙着，此寄存器中的其他位都无效。另外的 4 位暂不关注。

在写硬盘时，端口 0x1F7 或 0x177 的寄存器名称是 command，和上面说过的 error 和 feature 寄存器情况 一样，只是用途变了，所以换了个名字表示新的用途，它和 status 寄存器是同一个。此寄存器用来存储让硬 盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。在咱们的系统中，主要使用了三个命令：

1. identify：0xEC，即硬盘识别。
2. read sector：0x20，即读扇区。
3. write sector：0x30，即写扇区。

![image-20240727103411910](/home/abljiu/.config/Typora/typora-user-images/image-20240727103411910.png)



#### 常用的硬盘操作方法 

1. 先选择通道，往该通道的 sector count 寄存器中写入待操作的扇区数。
2. 往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位。
3. 往 device 寄存器中写入 LBA 地址的 24～27 位，并置第 6 位为 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（master 硬盘或 slave 硬盘）。
4. 往该通道上的 command 寄存器写入操作命令。
5. 读取该通道上的 status 寄存器，判断硬盘工作是否完成。
6. 如果以上步骤是读硬盘，进入下一个步骤。否则，完工。
7. 将硬盘数据读出。

一般常用的数据传送方式如下：

1. 无条件传送方式。
2. 查询传送方式。
3. 中断传送方式。
4. 直接存储器存取方式（DMA）。
5. I/O 处理机传送方式。

> loader 为什么在0x900

可用区域”的地方都可以用。 0x500～0x7BFF 和 0x7E00～9FBFF 这两段内存区域都可以。

首先，loader 中要定义一些数据结构（如 GDT 全局描述符表，不懂没关系，以后会说），这些数据结 构将来的内核还是要用的，所以 loader 加载到内存后不能被覆盖。 其次，随着咱们不断添加功能，内核必然越来越大，其所在的内存地址也会向越来越高的地方发展， 难免会超过可用区域的上限，咱们尽量把 loader 放在低处，多留出一些空间给内核。 所以，我将 loader 的加载地址选为 0x900。为什么不是 0x500，这个多省空间？还是预留出一定空间 吧，彼此隔开远一点心里才踏实，不差这点空间了，

## 第4章 保护模式入门

### 保护模式概述

#### 为什么要有保护模式

1. 实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。
2. 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地 指哪打哪。
3. 用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。
4. 访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。
5. 一次只能运行一个程序，无法充分利用计算机资源。
6. 共 20 条地址线，最大可用内存为 1MB，这即使在 20 年前也不够用。

#### 实模式不是32位cpu,变成了16位

32 位的 CPU 具备两 种运行模式，为区别这两种模式，根据之前 8086 的 16 位模式特性，将其称为实模式，为突显现在新模式 的优势，称新模式为保护模式。

### 初见保护模式

#### 保护模式之寄存器扩展

为了让一个寄存器就能访问 4GB 空间，需要寄存器宽度提升到 32 位。

各寄 存器在原有 16 位的基础上，再次向高位扩展了 16 位，成为了 32 位寄存器。经过 extend 后的寄存器，统 一在名字前加了 e 表示扩展

![image-20240729092850569](/home/abljiu/.config/Typora/typora-user-images/image-20240729092850569.png)

用全局描述符表来储存对段的描述信息，其中每一个表项成为段描述符，大小为64字节，用来描述各个内存段的起始地址、大小、 权限等信息，该全局描述符表很大， 所以放在了内存中，由 GDTR 寄存器指向它就行。

+ 段描述符是在内存中，访问内存对 CPU 来说是比较慢的动作，效率不高。（在 80286 的保护模式中，为了提高获取段信息的效率，对段寄存器率先应用了缓存技术，将段信息用一个寄存器来 缓存，这就是段描述符缓冲寄存器（Descriptor Cache Registers）。对程序员而言它是不可见的。CPU 每次 将千辛万苦获取到的内存段信息，整理成“完整的、通顺、不蹩脚”的形式后，存入段描述符缓冲寄存器， 以后每次访问相同的段时，就直接读取该段寄存器对应的段描述符缓冲寄存器）

+ 段描述符的格式很奇怪，一个数据要分三个地方存，所以 CPU 要把这些七零八落的数拼合成一 个完整数据也是要花时间的。

![image-20240729101600590](/home/abljiu/.config/Typora/typora-user-images/image-20240729101600590.png)、

有了保护模式，之前的实模式下的程序还得兼容，所以便有了个“过渡模式”，即虚拟 8086 模式。

综上所述，CPU 有三种模式：实模式、虚拟 8086 模式、保护模式。

#### 保护模式之寻址扩展 

![image-20240729110111545](/home/abljiu/.config/Typora/typora-user-images/image-20240729110111545.png)

#### 保护模式之运行模式反转 

进入保护模式需要三个步骤\

1. 打开 A20
2. 加载 gdt
3. 将 cr0 的 pe 位置 1

>  操作数反转前缀 0x66

在指令中添加了 0x66 反转前缀之后： 假设当前运行模式是 16 位实模式，操作数大小将变为 32 位。 假设当前运行模式是 32 位保护模式，操作数大小将变为 16 位。 注意啦，这个转换只是临时的，只在当前指令有效。  

![image-20240729115218972](/home/abljiu/.config/Typora/typora-user-images/image-20240729115218972.png)

>  寻址方式反转前缀 0x67

![image-20240729115252306](/home/abljiu/.config/Typora/typora-user-images/image-20240729115252306.png)

#### 保护模式之指令扩展 

在 16 位的实模式下，CPU 的操作数是 16 位。在 32 位的保护模式下，操作数扩展到了 32 位，于是 涉及到操作数变化的指令也要跟着扩展，既要兼容 16 的操作数，也要支持 32 位的操作数。

在保护模式下，同样是这些压入立即数的指令，栈指针会有怎样的变化呢？ 

当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针 减 4。 当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。 当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

对于通用寄存器和内存，无论是在实模式或保护模式：

+ 如果压入的是 16 位数据，栈指针减 2。
+ 如果压入的是 32 位数据，栈指针减 4。

### 全局描述符表

#### 段描述符 

![image-20240729203516524](/home/abljiu/.config/Typora/typora-user-images/image-20240729203516524.png)



段界限表示段边界的扩展最值，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。对于 数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对 于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。

段描述符的第 12 位是 S 字段，前面在介绍 type 时已解释过啦，用来指出当前描述符是否是系统段。 S 为 0 表示系统段，S 为 1 表示非系统段。

 段描述符的第 13～14 位是 DPL 字段，Descriptor Privilege Level，即描述符特权级，这是保护模式提 供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。

段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。

段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。不过这“可用的”是对用 户来说的。

段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32 位代码段。这目前属于保留位，在我们 32 位 CPU 下编程，将其置为 0 便可。

段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。有没有觉得 奇怪，实模式已经是 32 位的地址线和操作数了，难道操作数不是 32 位大小吗？其实这是为了兼容 286 的 保护模式，286 的保护模式下的操作数是 16 位。

段描述符的第 23 位是 G 字段，Granularity，粒度，用来指定段界限的单位大小。所以此位是用来配 合段界限的，它与段界限一起来决定段的大小。若 G 为 0，表示段界限的单位是 1 字节，这样段最大是 2 的 20 次方*1 字节，即 1MB。若 G 为 1，表示段界限的单位是 4KB，这样段最大是 2 的 20 次方*4KB 字 节，即 4GB。

type字段：

![image-20240730101953535](/home/abljiu/.config/Typora/typora-user-images/image-20240730101953535.png)



表中的 A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。 所以，创建一个新段描述符时，应该将此位置 0。我们在调试时，根据此位便能判断该描述符是否可用啦。 

C 表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段， 并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主， 而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码 段，C 为 0 时则表示该段为非一致性代码段。 

R 表示可读，R 为 1 表示可读，R 为 0 表示不可读。这个属性一般用来限制代码段的访问。如果指令 执行过程中，CPU 发现某些指令对 R 为 0 的段进行访问，如使用段超越前缀 CS 来访问代码段，CPU 将 抛出异常。啰嗦一小下，内存中的数据对 CPU 来说是要处理的数据，仅仅是 CPU 的输入而已，CPU 的铁 骑可以踏遍任意角落。所以，不可读的代码段只是来限制代码指令的，并不是连 CPU 也不能看。

 X 表示该段是否可执行，EXecutable。我们所说的指令和数据，在 CPU 眼中是没有任何区别的，都是 010101 这样类似的二进制。所以要用 type 中的 X 位来标识出是否是可执行的代码。代码段是可执行的， 即 X 为 1。而数据段是不可执行的，即 X 为 0。

E 是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数 据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。 

W 是指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0 表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。

#### 全局描述符表 GDT、局部描述符表 LDT 及选择子

`全局描述符表 GDT` 相当于是描述符的数组，数组中的每个元素都是 8 字节的描述符。可以用选择子（马上会讲到）中提供的下标在 GDT 中索引描述符。

全局描述符表位于内存中，需要用专门的寄存器指向它后，CPU 才知道它在哪里。这个专门的寄存器便是 GDTR， 即 GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器

![image-20240729212259924](/home/abljiu/.config/Typora/typora-user-images/image-20240729212259924.png)

![image-20240729213015108](/home/abljiu/.config/Typora/typora-user-images/image-20240729213015108.png)

在保护模式下时，由于段基址已经存入了段描述符中，所以段寄存器中再存放段基址是没有意义的，在段寄 存器中存入的是一个叫作`选择子`的东西—selector。

![image-20240729213305899](/home/abljiu/.config/Typora/typora-user-images/image-20240729213305899.png)

由于段寄存器是 16 位，所以选择子也是 16 位，在其低 2 位即第 0～1 位， 用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。

在选 择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。

选择子的高 13 位，即第 3～15 位是 描述符的索引值，用此值在 GDT 中索引描述符。

GDT 中的第 0 个段描述符是不可用的，原因是定义在 GDT 中的段描 述符是要用选择子来访问的，如果使用的选择子忘记初始化，选择子的值便会是 0，这便会访问到第 0 个 段描述符。为了避免出现这种因忘记初始化选择子而选择到第 0 个段描述符的情况，GDT 中的第 0 个段 描述符不可用。也就是说，若选择到了 GDT 中的第 0 个描述符，处理器将发出异常。

`局部描述符表`叫 LDT，Local Descriptor Table，它是 CPU 厂商为在硬件一级原生支持多任务而创造的表,按照 CPU 的设想，一个任务对应一个 LDT。其实在现代 操作系统中很少有用 LDT 的，我们系统中也未用 LDT。

#### 打开A20地址线

![image-20240730094432045](/home/abljiu/.config/Typora/typora-user-images/image-20240730094432045.png)

IBM 在键盘控制器上的一些输出线来控制第 21 根地址线（A20）的有效性，故被 称为 A20Gate。

+ 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存。
+ 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

#### 保护模式的开关，CR0 寄存器的 PE 位 

![image-20240730095351557](/home/abljiu/.config/Typora/typora-user-images/image-20240730095351557.png)

#### 流水线 

流水线是 CPU 提高效率的一种出路,通过将步骤更加细分来提高效率

![image-20240731110440021](/home/abljiu/.config/Typora/typora-user-images/image-20240731110440021.png)

#### 乱序执行 

乱序执行，是指在 CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执 行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。

#### 缓存

缓存是 20 世纪最大的发明，其原理是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度 较慢的低速存储设备，归根结底的原因是低速存储设备是整个系统的瓶颈，缓存用来缓解“瓶颈设备”的压力。

#### 分支预测 

预测的算法：

对于无条件跳转，没啥可犹豫的，直接跳过去就是了。所谓的预测是针对有条件跳转来说的，因为不 知道条件成不成立。

最简单的统计是根据上一次跳转的结果来预测本次，如果上一次跳转啦，这一次也预 测为跳转，否则不跳。 最简单的方法是 2 位预测法。用 2 位 bit 的计数器来记录跳转状态，每跳转一次就加 1，直到加到最 大值 3 就不再加啦，如果未跳转就减 1，直到减到最小值 0 就不再减了。当遇到跳转指令时，如果计数器 的值大于 1 则跳转，如果小于等于 1 则不跳。

CPU 是如何实现预测：

> Intel 的分支预测部件中用了分支目标缓冲器（Branch Target Buffer，BTB）

![image-20240731115827993](/home/abljiu/.config/Typora/typora-user-images/image-20240731115827993.png)

BTB 中记录着分支指令地址，CPU 遇到分支指令时，先 用分支指令的地址在 BTB 中查找，若找到相同地址的指令，根据跳转统计信息判断是否把相应的预测分 支地址上的指令送上流水线。在真正执行时，根据实际分支流向，更新 BTB 中跳转统计信息。

如果 BTB 中没有相同记录,就使用 Static Predictor，静态预测器。为什么称为静 态呢？这是因为存储在里面的预测策略是固定写死的，它是由人们经过大量统计之后，根据某些特征总结 出来的。比如，转移目标的地址若小于当前转移指令的地址，则认为转移会发生，因为通常循环结构中都 用这种转移策略，为的是组成循环回路。所以静态预测器的策略是：若向上跳转则转移会发生，若向下跳 转则转移不发生

![image-20240731192021870](/home/abljiu/.config/Typora/typora-user-images/image-20240731192021870.png)

### 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

段描述符缓冲寄存器在 CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符 缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器 中的内容为主。实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的 20 位的段 基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄 存器，也就是要想办法往相应段寄存器中加载选择子。

实模式到保护模式转换的过程中，操作数大小从16位转到32位，但是进入保护模式后需要转化为32位指令，但是在进行 `[bits 32]`之前代码就已经进入流水线准备进行处理了，所以流水线上的代码依旧是16位，需要使用jmp清空流水线。 

### 保护模式之内存段的保护

#### 向段寄存器加载选择子时的保护

引用内存段时，会检查段寄存器中加载的选择子：

+ 首先检查选择子的段描述符是否超越界限

![image-20240731200302942](/home/abljiu/.config/Typora/typora-user-images/image-20240731200302942.png)

+ 检查读研的类型

  + 只有具备可执行属性的段（代码段）才能加载到 CS 段寄存器中。
  + 只具备执行属性的段（代码段）不允许加载到除 CS 外的段寄存器中。
  + 只有具备可写属性的段（数据段）才能加载到 SS 栈段寄存器中。
  + 至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中。

  ![image-20240731200901145](/home/abljiu/.config/Typora/typora-user-images/image-20240731200901145.png)

  ![image-20240731201157344](/home/abljiu/.config/Typora/typora-user-images/image-20240731201157344.png)

  

+ 最后检查段是否存在，通过检查段描述符中的p位来确认内存段是否存在，1存在。同时更新段描述符缓冲寄存器，随后将段描述符中的A置为1

#### 代码段和数据段的保护

对于G位为1的4k力度的段来说，实际段界限的值为：实际段界限大小 = 描述符中段界限*0x1000+0xFFF 

CS：EIP是指令的起始地址，需要确保指令完全在当前的代码段内，需要满足以下条件：EIP 中的偏移地址+指令长度-1≤实际段界限大小
![image-20240731202618539](/home/abljiu/.config/Typora/typora-user-images/image-20240731202618539.png)

#### 栈段的保护

CPU 对数据段的检查，其中一项就是看地址是否超越段界限。如果将向上扩展的数据段用作栈，那 CPU 将按照上一节提到的数据段的方式检查该段。如果用向下扩展的段做栈的话，情况有点复杂，这体 现在段界限的意义上。

+ 对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。
+ 对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节

![image-20240731203021313](/home/abljiu/.config/Typora/typora-user-images/image-20240731203021313.png)

## 第5章 保护模式进阶，向内核迈进

### 获取物理内存容量

#### 学习 Linux 获取内存的方法 

Linux 2.6 内核 中，是用 detect_memory 函数来获取内存容量的，其函数在本质上是通过调用 BIOS 中断 0x15 实现的，分别 是 BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中，如下

+ EAX=0xE820：遍历主机上全部内存。
+ AX=0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持 4GB。
+ AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。

#### 利用 BIOS 中断 0x15 子功能 0xe820 获取内存 

BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同， BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存 信息，直到将所有内存类型返回完毕。子功能 0xE820 的强大之处是返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符

![image-20240731212227299](/home/abljiu/.config/Typora/typora-user-images/image-20240731212227299.png)

此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 int 0x15 之后，BIOS 就返回这样一个结构的数据

![image-20240731212429577](/home/abljiu/.config/Typora/typora-user-images/image-20240731212429577.png)

内存可能是：

+ 系统的 ROM。
+ ROM 用到了这部分内存。
+ 设备内存映射到了这部分内存。 
+ 由于某种原因，这段内存不适合标准设备使用

![image-20240801092659798](/home/abljiu/.config/Typora/typora-user-images/image-20240801092659798.png)

![image-20240801092718156](/home/abljiu/.config/Typora/typora-user-images/image-20240801092718156.png)

#### 利用 BIOS 中断 0x15 子功能 0xe801 获取内存

这个方法最大只能识别4GB内存，分别存放到两组寄存器中，低于15MB的内存以1KB位单位大小来记录，16MB～4GB是以64KB为单位大小来记录的。

![image-20240801094059734](/home/abljiu/.config/Typora/typora-user-images/image-20240801094059734.png)

中断返回 后，AX 和 CX 中，其值的单位是 1KB，而 BX 和 DX 的单位是 64KB。

#### 利用 BIOS 中断 0x15 子功能 0x88 获取内存 

最后一个获取内存的方法也同样是 BIOS 0x15 中断，子功能号是 0x88。该方法只能识别最大64MB内存，此中断只会显示1MB之上的内存，不包括这1MB。
![image-20240801095301765](/home/abljiu/.config/Typora/typora-user-images/image-20240801095301765.png)

### 启用内存分页机制，畅游虚拟空间

#### 内存为什么要分页

![image-20240801110557820](/home/abljiu/.config/Typora/typora-user-images/image-20240801110557820.png)

两个解决方案：

+ 等待进程 C 运行完后腾出内存，这样连续可用的内存就够运行进程 D 了。
+ 将进程 A 的段 A3 或进程 C 的段 C1 换出到硬盘上，腾出一部分空间，加上邻接的 20MB，足够容 纳进程 D。

#### 一级页表

![image-20240801113730854](/home/abljiu/.config/Typora/typora-user-images/image-20240801113730854.png)

分页机制的作用有两方面:

+ 将线性地址转换成物理地址
+ 用大小相等的页代替大小不等的段

![image-20240801113945492](/home/abljiu/.config/Typora/typora-user-images/image-20240801113945492.png)

![image-20240801114233613](/home/abljiu/.config/Typora/typora-user-images/image-20240801114233613.png)

+ 分页机制打开前要将页表地址加载到控制寄存器 cr3 中，这是启用分页机制的先决条件之一，在 介绍二级页表时会细说。所以，在打开分页机制前加载到寄存器 cr3 中的是页表的物理地址，页表中页表 项的地址自然也是物理地址了。
+ 虽然内存分页机制的作用是将虚拟地址转换成物理地址，但其转换过程相当于在关闭分页机制下 进行，过程中所涉及到的页表及页表项的寻址，它们的地址都被 CPU 当作最终的物理地址（本来也是物 理地址）直接送上地址总线，不会被分页机制再次转换（否则会递归转换下去）。

一个页表项对应一个页，所以，用线性地址的高 20 位作为页表项的索引，每个页表项要占用 4 字节 大小，所以这高 20 位的索引乘以 4 后才是该页表项相对于页表物理地址的字节偏移量。用 cr3 寄存器中 的页表物理地址加上此偏移量便是该页表项的物理地址，从该页表项中得到映射的物理页地址，然后用线 性地址的低 12 位与该物理页地址相加，所得的地址之和便是最终要访问的物理地址。

总结一下页部件的工作：用线性地址的高 20 位在页表中索引页表项，用线性地址的低 12 位与页表项 中的物理地址相加，所求的和便是最终线性地址对应的物理地址

![image-20240801115717047](/home/abljiu/.config/Typora/typora-user-images/image-20240801115717047.png)

#### 二级页表

为什么要有二级页表

+ 一级页表中最多可容纳 1M（1048576）个页表项，每个页表项是 4 字节，如果页表项全满的话， 便是 4MB 大小。 
+ 一级页表中所有页表项必须要提前建好，原因是操作系统要占用 4GB 虚拟地址空间的高 1GB， 用户进程要占用低 3GB
+ 每个进程都有自己的页表，进程一多，光是页表占用的空间就很可观了

![image-20240801193309103](/home/abljiu/.config/Typora/typora-user-images/image-20240801193309103.png)

      二级页表虚拟地址转化物理地址：

1. 用虚拟地址的高 10 位乘以 4，作为页目录表内的偏移地址，加上页目录表的物理地址，所得的 和，便是页目录项的物理地址。读取该页目录项，从中获取到页表的物理地址。 
2. 用虚拟地址的中间 10 位乘以 4，作为页表内的偏移地址，加上在第 1 步中得到的页表物理地址， 所得的和，便是页表项的物理地址。读取该页表项，从中获取到分配的物理页地址。 
3. 虚拟地址的高 10 位和中间 10 位分别是 PDE 和 PTE 的索引值，所以它们需要乘以 4。但低 12 位 就不是索引值啦，其表示的范围是 0～0xfff，作为页内偏移最合适，所以虚拟地址的低 12 位加上第 2 步 中得到的物理页地址，所得的和便是最终转换的物理地址。

![image-20240801194339442](/home/abljiu/.config/Typora/typora-user-images/image-20240801194339442.png)

![image-20240801194713246](/home/abljiu/.config/Typora/typora-user-images/image-20240801194713246.png)

页目录项和页表项的结构：

![image-20240801194725840](/home/abljiu/.config/Typora/typora-user-images/image-20240801194725840.png)

+ P，Present，意为存在位。若为 1 表示该页存在于物理内存中，若为 0 表示该表不在物理内存中。操 作系统的页式虚拟内存管理便是通过 P 位和相应的 pagefault 异常来实现的。
+ RW，Read/Write，意为读写位。若为 1 表示可读可写，若为 0 表示可读不可写。 
+ US，User/Supervisor，意为普通用户/超级用户位。若为 1 时，表示处于 User 级，任意级别（0、1、2、 3）特权的程序都可以访问该页。若为 0，表示处于 Supervisor 级，特权级别为 3 的程序不允许访问该页， 该页只允许特权级别为 0、1、2 的程序可以访问。 
+ PWT，Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式， 表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，“通写”是高速缓存的一种工作方式， 本位用来间接决定是否用此方式改善该页的访问效率。这里咱们直接置为 0 就可以啦。 
+ PCD，Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表 示禁止将该页缓存。这里咱们将其置为 0。 
+ A，Accessed，意为访问位。若为 1 表示该页被 CPU 访问过啦，所以该位是由 CPU 设置的。还记得段 描述符中的 A 位和 P 位吗？这两位在一起可以实现段式虚拟内存管理。和它们一样，这里页目录项和页表 项中的 A 位也可以用来记录某一内存页的使用频率（操作系统定期将该位清 0，统计一段时间内变成 1 的次 数），从而当内存不足时，可以将使用频率较低的页面换出到外存（如硬盘），同时将页目录项或页表项的 P 位置 0，下次访问该页引起 pagefault 异常时，中断处理程序将硬盘上的页再次换入，同时将 P 位置 1。 
+ D，Dirty，意为脏页位。当 CPU 对一个页面执行写操作时，就会设置对应页表项的 D 位为 1。此项 仅针对页表项有效，并不会修改页目录项中的 D 位。 
+ PAT，Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，将 此位置 0 即可。 
+ G,Global，意为全局位。由于内存地址转换也是颇费周折，先得拆分虚拟地址，然后又要查页目录，又要 查页表的，所以为了提高获取物理地址的速度，将虚拟地址与物理地址转换结果存储在 TLB（Translation Lookaside Buffer）中，TLB 以后咱们会细说。在此先知道 TLB 是用来缓存地址转换结果的高速缓存就 ok 啦。 此 G 位用来指定该页是否为全局页，为 1 表示是全局页，为 0 表示不是全局页。若为全局页，该页将在高速 缓存 TLB 中一直保存，给出虚拟地址直接就出物理地址啦，无需那三步骤转换。由于 TLB 容量比较小（一般 速度较快的存储设备容量都比较小），所以这里面就存放使用频率较高的页面。顺便说一句，清空 TLB 有两种 方式，一是用 invlpg 指令针对单独虚拟地址条目清理，或者是重新加载 cr3 寄存器，这将直接清空 TLB。
+  AVL，意为 Available 位，表示可用，谁可以用？当然是软件，操作系统可用该位，CPU 不理会该位 的值，那咱们也不理会吧。

启用分页机制，我们要按顺序做好三件事：

1. 准备好页目录表及页表。
2. 将页表地址写入控制寄存器 cr3。
3. 寄存器 cr0 的 PG 位置 1。

控制寄存器 cr3 用于存储页表物理地址，所以 cr3 寄存器又称为页目录基址寄存器（Page Directory Base Register，PDBR）。

![image-20240801195721671](/home/abljiu/.config/Typora/typora-user-images/image-20240801195721671.png)

#### 规划页表之操作系统与用户进程的关系

![image-20240801200322457](/home/abljiu/.config/Typora/typora-user-images/image-20240801200322457.png)

> 虚拟地址空间的 0～3GB 是用户进程，3GB～4GB 是操作系统。 

#### 启用分页机制 

![image-20240801201331234](/home/abljiu/.config/Typora/typora-user-images/image-20240801201331234.png)

####  用虚拟地址访问页表

这三个怪异的虚拟地址:

+ 提取出关键一点：高 10 位若为 0x3ff，则会访问到页目录表中最后一个页目录项，由于页表中也是 1024 个页表项，故中间 10 位若为 0x3ff，则会访问到页表中最后一个页表项。
+ 虚拟地址 0xfff00000 的高 10 位依然为 0x3ff，中间 10 位是 1100000000b=0x300，这是第 768 个页目录 项，该页目录项指向的页表与第 0 个页目录项指向的页表相同。所以虚拟地址 0xfff00000 映射为物理地址 0x00101000 成立，这下大家也容易理解 0xfff00fff 映射为 0x00101fff。
+ 提炼再提炼，如果虚拟地址的高 20 位为 0xfffff，经过我们的页目录表映射，将会访问到页目录表自 己的物理地址。

总结一下用虚拟地址获取页表中各数据类型的方法:

+ 获取页目录表物理地址：让虚拟地址的高 20 位为 0xfffff，低 12 位为 0x000，即 0xfffff000，这也 是页目录表中第 0 个页目录项自身的物理地址
+ 访问页目录中的页目录项，即获取页表物理地址：要使虚拟地址为 0xfffffxxx，其中 xxx 是页目录 项的索引乘以 4 的积
+ 访问页表中的页表项：要使虚拟地址高 10 位为 0x3ff，目的是获取页目录表物理地址。中间 10 位 为页表的索引，因为是 10 位的索引值，所以这里不用乘以 4。低 12 位为页表内的偏移地址，用来定位页 表项，它必须是已经乘以 4 后的值。

> 公式为 0x3ff<<22+中间 10 位<<12+低 12 位

#### 快表 TLB（Translation Lookaside Buffer）简介 

虚拟地址到物理地址的转换十分繁琐且内存效率低下，处理器准备了一个高速缓存，可以匹配高速的处理器速率和低速的内 存访问速度，它专门用来存放虚拟地址页框与物理地址页框的映射关系，这个调整缓存就是 TLB，即 Translation Lookaside Buffer，俗称快表

![image-20240802114611247](/home/abljiu/.config/Typora/typora-user-images/image-20240802114611247.png)

### 加载内核

#### 用 C 语言写内核 

-c 的作用是编译、汇编到目标代码，不进行链接，也就是直接生成目标文件。 

-o 的作用是将输出的文件以指定文件名来存储，有同名文件存在时直接覆盖。

在 Linux 下用于链接的程序是 ld，链接有一个好处，可以指定最终生成的可执行文件的起始虚拟地址。 它是用-Ttext 参数来指定的，所以咱们可以执行以下命令完成链接。 ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin 

-e 和--entry 一样，字面上的意思是用来指定程序的起始地址。注意，不要被迷惑了，虽然说是指定起 始地址，但参数不仅可以是数字形式的地址，而且可以是符号名，这和汇编中的标号也是地址是一样的道 理。总之它用来指定程序从哪里开始执行。

> _start 是程序真正的入口地址

#### 二进制程序的运行方法

在程序中，程序头用来描述程序的布局等信息，它属于信息的信息，也就是元数据。

![image-20240805195012625](/home/abljiu/.config/Typora/typora-user-images/image-20240805195012625.png)

#### elf 格式的二进制文件 

Window 下的可执行文件格式是 PE（如果您想说的是 EXE，不要搞混了，EXE 是扩展名，属于文件名的一部分，只是名字的后缀，它并不是真正的格式），PE 即 Portable Executable， Linux 下可执行文件格式是 ELF。

ELF 指的是 Executable and Linkable Format，可执行链接格式。最初是由 UNIX 系统实验室（USL） 作为应用程序二进制接口（ABI）而开发和发行的。工具接口标准委员会（TIS）选择了它作为 IA32 体系 结构上不同操作系统之间的可移植二进制文件格式，于是它就发展成为了事实上的二进制文件格式标准。

![image-20240805200420690](/home/abljiu/.config/Typora/typora-user-images/image-20240805200420690.png)

![image-20240805200948146](/home/abljiu/.config/Typora/typora-user-images/image-20240805200948146.png)

#### 将内核载入内存

加载内核：需要把内核文件加载到内存缓冲区。 

初始化内核：需要在分页后，将加载进来的 elf 内核文件安置到相应的虚拟内存地址，然后跳过去 执行，从此 loader 的工作结束。

内核被加载到内存后，loader 还要通过分析其 elf 结构将其展开到新的位置，所以说，内核在内存中有 两份拷贝，一份是 elf 格式的原文件 kernel.bin，另一份是 loader 解析 elf 格式的 kernel.bin 后在内存中生成的 内核映像（也就是将程序中的各种段 segment 复制到内存后的程序体），这个映像才是真正运行的内核。

![image-20240807095758031](/home/abljiu/.config/Typora/typora-user-images/image-20240807095758031.png)

### 特权级深入浅出

#### 特权级那点事 

建立特权机制是为了通过特权来检查合法性，整个计算机世界的特权检查，都是发生在“访问者”在 访问“受访者”的一刹那，实际上就是检查访问者的特权级和受访者的特权级是否匹配。

特权级按照权力从大到小分为 0、1、2、3 级，没错，数字越小，权力越大，0 级特权能力最大，3 级特权能力最小。

![image-20240807100117000](/home/abljiu/.config/Typora/typora-user-images/image-20240807100117000.png)

#### TSS 简介 

TSS，即 Task State Segment，意为任务状态段， 它是处理器在硬件上原生支持多任务的一种实现方 式，也就是说处理器原本是想让操作系统开发厂商利 用此结构实现多任务的，人家处理器厂商已经提供了 多任务管理的解决方案，尽管后来操作系统并不买账

![image-20240807100546567](/home/abljiu/.config/Typora/typora-user-images/image-20240807100546567.png)

TSS 是硬件支持的系统数据结构，它和 GDT 等一样，由软件填写其内容，由硬件使用。GDT 也要加 载到寄存器 GDTR 中才能被处理器找到，TSS 也是一样，它是由 TR（Task Register）寄存器加载的，每 次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS 就成了

#### CPL 和 DPL 入门 

在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是代 码段描述符中的 DPL，便是当前 CPU 所处的特权级，这个特权级称为当前特权级，即 CPL（Current Privilege Level），它表示处理器正在执行的代码的特权级别。除一致性代码段外（后面会说），转移后的目标代码 据段的 DPL 是将来处理器的当前特权级 CPL。

一致性代码段也称为依从代码段，Conforming，用来实现从低特权级的代码向高特权级的代码转移。一 致性代码段是指如果自己是转移后的目标段，自己的特权级（DPL）一定要大于等于转移前的 CPL，即数值 上 CPL≥DPL，也就是一致性代码段的 DPL 是权限的上限，任何在此权限之下的特权级都可以转到此代码 段上执行。

> 唯一一种处理器会从高特权降到低特权运行的情况：处理器从中断处理程序中返回到用户态的时候。

#### 门、调用门与 RPL 序 							

门结构是什么呢？就是记录一段程序起始地址的描述符。

![image-20240807110550028](/home/abljiu/.config/Typora/typora-user-images/image-20240807110550028.png)

![image-20240807110601668](/home/abljiu/.config/Typora/typora-user-images/image-20240807110601668.png)

![image-20240807110615567](/home/abljiu/.config/Typora/typora-user-images/image-20240807110615567.png)

![image-20240807110808424](/home/abljiu/.config/Typora/typora-user-images/image-20240807110808424.png)

任务门、调用门都可以用 call 和 jmp 指令直接调用，原因是这两个门描述符都位于描述符表中，要么 是 GDT，要么是 LDT，访问它们同普通的段描述符是一样的，也必须要通过选择子，因此只要在 call 或 jmp 指令后接任务门或调用门的选择子便可调用它们了。陷阱门和中断门只存在于 IDT 中，因此不能主动 调用，只能由中断信号来触发调用。

+ `调用门` call 和 jmp 指令后接调用门选择子为参数，以调用函数例程的形式实现从低特权向高特权转移，可用来实 现系统调用。call 指令使用调用门可以实现向高特权代码转移，jmp 指令使用调用门只能实现向平级代码转移。 

![image-20240807195707604](/home/abljiu/.config/Typora/typora-user-images/image-20240807195707604.png)

+ `中断门`以 int 指令主动发中断的形式实现从低特权向高特权转移，Linux 系统调用便用此中断门实现，以后咱 们在实现中断时会展开细说。 

+ `陷阱门`以 int3 指令主动发中断的形式实现从低特权向高特权转移，这一般是编译器在调试时用，本书中咱们 不用过多关注。 

+ `任务门`任务以任务状态段 TSS 为单位，用来实现任务切换，它可以借助中断或指令发起。当中断发生时， 如果对应的中断向量号是任务门，则会发起任务切换。也可以像调用门那样，用 call 或 jmp 指令后接任务 门的选择子或任务 TSS 的选择子

#### 调用门的过程保护 

如果在返回时需要改变特权级，将会检查数据段寄存器 DS、ES、FS 和 GS 的内容，如果在它 们之中，某个寄存器中选择子所指向的数据段描述符的 DPL 权限比返回后的 CPL（CS.RPL）高，即数值 上返回后的 CPL>数据段描述符的 DPL，处理器将把数值 0 填充到相应的段寄存器，这种 0 值的选择子就会在 GDT 中检索到第 0 个哑描述符，从而引发处理器的异常。

#### RPL 的前世今生 

仅通过CPL和DPL会出现漏洞：受访者不知道访问者的真实身份，在受访者看来，是 0 特权级的操作 系统想要数据，它还以为请求者是操作系统呢。实际情况是请求者为 3 特权级下的用户程序，内核程序只 是代替用户程序来拿数据的。即资源的真正请求者是用户程序，而它却是破坏者。用户程序所处的特权级 为 3，按道理低特权级的访问者是不被允许访问这些高特权级的内核资源。

RPL，Request Privilege Level，请求特权级，它代表真正请求者的 特权级。用户进程通过调用门提升CPL后，旧的CPL会被保存在RPL中，防止非法访问内核的操作。

#### IO 特权级

![image-20240809094253050](/home/abljiu/.config/Typora/typora-user-images/image-20240809094253050.png)

如果当前特权级CPL大于IOPL则可以访问全部的IO端口，如果小于则可以通过IO位图来设置部分端口的访问权限。也就是说，先在整体上关闭，再从局部上打开。

![image-20240809094648816](/home/abljiu/.config/Typora/typora-user-images/image-20240809094648816.png)

![image-20240809094659740](/home/abljiu/.config/Typora/typora-user-images/image-20240809094659740.png)
处理器要求位图的最后一字节必须是 0xFF，此字节有两个作用：

1. 处理器允许 I/O 位图中不映射所有的端口，即 I/O 位图长度可以不足 8KB，但位图的最后一字 节必须为 0xFF。如果在位图范围外的端口，处理器一律默认禁止访问。这样一来，如果位图最后一字节 的 0xFF 属于全部 65536 个端口范围之内，字节各位全为 1 表示禁止访问此字节代表的全部端口，这并没 什么过错。 
2. 如果该字节已经超过了全部端口的范围，它并不用来映射端口，只是用来作为位图的边界标记， 用于跨位图最后一个字节时的“余量字节”。
3. 避免越界访问 TSS 外的内存。

## 完善内核

### 函数调用约定简介

![image-20240809101805997](/home/abljiu/.config/Typora/typora-user-images/image-20240809101805997.png)

stdcall 的调用约定

1. 调用者将所有参数从右向左入栈。
2. 被调用者清理参数所占的栈空间。

cdecl 的调用约定

1. 调用者将所有参数从右向左入栈。
2. 调用者清理参数所占的栈空间。

### 汇编语言和 C 语言混合编程

#### 浅析 C 库函数与系统调用 

汇编语言和 C 语言混合编程可分为两大类

1. 单独的汇编代码文件与单独的 C 语言文件分别编译成目标文件后，一起链接成可执行程序。 
2. 在 C 语言中嵌入汇编代码，直接编译生成可执行程序。

系统调用通过中段描述符表，所以只选用一个中断号0x80作为系统调用入口，具体的子功能在寄存器eax中单独指定。

调用“系统调用”有两种方式。 

1. 将系统调用指令封装为 c 库函数，通过库函数进行系统调用，操作简单。 
2. 不依赖任何库函数，直接通过汇编指令 int 与操作系统通信

### 实现自己的打印函数

#### 实现单个字符打印 

> 实现putchar 

1. 备份寄存器现场。 
2. 获取光标坐标值，光标坐标值是下一个可打印字符的位置。
3. 获取待打印的字符。 
4. 判断字符是否为控制字符，若是回车符、换行符、退格符三种控制字符之一，则进入相应的处理 流程。否则，其余字符都被粗暴地认为是可见字符，进入输出流程处理。 
5. 判断是否需要滚屏。 
6. 更新光标坐标值，使其指向下一个打印字符的位置。
7. 恢复寄存器现场，退出。

![image-20240812103956223](/home/abljiu/.config/Typora/typora-user-images/image-20240812103956223.png)

## 中断

### 操作系统是中断驱动的

> 操作系统是个死循环

其实，这个死循环本身做不了什么大事，仅仅是保证操作系统能够周而复始地运行下去，而运行的目 的是为了等候某些事情发生。您看，我说的是等候，也就是操作系统是被动工作的，有事情发生它才会工 作，所以它是被事件驱动的，而这个事件是以中断的形式通知操作系统的，所以说，操作系统是中断驱动 的，这一点也没有错。

### 中断分类

####  外部中断 

外部中断是指来自 CPU 外部的中断，而外部的中断源必须是某个硬件，所以外部中断又称为硬件中断。比如说网卡收到了来自网络的数据包，这时候网卡就会主动通知 CPU，CPU 得到通知后便将数据拷 贝到内核缓冲区.

![image-20240813092806947](/home/abljiu/.config/Typora/typora-user-images/image-20240813092806947.png)

+ 可屏蔽中断是通过 INTR 引脚进入 CPU 的，外部设备如硬盘、网卡等发出的中断都是可屏蔽中断。 可屏蔽的意思是此外部设备发出的中断，CPU 可以不理会，因为它不会让系统宕机，所以可以通过 eflags 寄存器的 IF 位将所有这些外部设备的中断屏蔽。

+ 不可屏蔽中断是通过 NMI 引脚进入 CPU 的，它表示系统中发生了致命的错误，它等同于宣布：计算 机的运行到此结束了。

CPU 收到中断后，得知道发生了什么事情才能执行相应的处理办法。这是通过中断向量表或中断描述 符表（中断向量表是实模式下的中断处理程序数组，在保护模式下已经被中断描述符表代替，在后面章节 中会细说）来实现的，首先为每一种中断分配一个中断向量号，中断向量号就是一个整数，它就是中断向 量表或中断描述符表中的索引下标，用来索引中断项。中断发起时，相应的中断向量号通过 NMI 或 INTR 引脚被传入 CPU，中断向量号是中断向量表或中断描述符表里中断项的下标，CPU 根据此中断向量号在 中断向量表或中断描述符表中检索对应的中断处理程序并去执行。

#### 内部中断

> 内部中断可分为软中断和异常。 

+ 软中断，就是由软件主动发起的中断，因为它来自于软件，所以称之为软中断。由于该中断是软件运 行中主动发起的，所以它是主观上的，并不是客观上的某种内部错误。

+ 下面说说异常，异常是另一种内部中断，是指令执行期间 CPU 内部产生的错误引起的。 由于是运行时错误，所以它不受标志寄存器 eflags 中的 IF 位影响，无法向用户隐瞒（因为运行不下 去了，错误兜不住了）。

异常，按照轻重程度，可以分为以下三种:

1. Fault，也称为故障。这种错误是可以被修复的一种类型，属于最轻的一种异常，它给软件一次“改 过自新”的机会。当发生此类异常时 CPU 将机器状态恢复到异常之前的状态，之后调用中断处理程序时， CPU 将返回地址依然指向导致 fault 异常的那条指令。通常中断处理程序中会将此问题修复，待中断处理 程序返回后便能重试。最典型的例子就是操作系统课程中所说的缺页异常 page fault，话说 Linux 的虚拟内 存就是基于 page fault 的，这充分说明这种异常是极易被修复的，甚至是有益的。 
2. Trap，也称为陷阱，这一名称很形象地说明软件掉进了 CPU 设下的陷阱，导致停了下来。此异 常通常用在调试中，比如 int3 指令便引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU 将中断处理程序的返回地址指向导致异常指令的下一个指令地址。 
3. Abort，也称为终止，从名字上看，这是最严重的异常类型，一旦出现，由于错误无法修复，程 序将无法继续运行，操作系统为了自保，只能将此程序从进程表中去掉。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。

### 中断描述符表

对比中断向量表，中断描述符表有两个区别

1. 中断描述符表地址不限制，在哪里都可以。
2. 中断描述符表中的每个描述符用 8 字节描述。

![image-20240813103149173](/home/abljiu/.config/Typora/typora-user-images/image-20240813103149173.png)

#### 中断处理过程及保护 

完整的中断过程分为 CPU 外和 CPU 内两部分

+ CPU 外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到 CPU。
+ CPU 内：CPU 执行该中断向量号对应的中断处理程序。

1. 处理器根据中断向量号定位中断门描述符。
2. 处理器进行特权级检查。
   1. 如果是由软中断 int n、int3 和 into 引发的中断，这些是用户进程中主动发起的中断，由用户代码 控制，处理器要检查当前特权级 CPL 和门描述符 DPL，这是检查进门的特权下限，如果 CPL 权限大于等 于 DPL，即数值上 CPL≤门描述符 DPL，特权级“门槛”检查通过，进入下一步的“门框”检查。否则， 处理器抛出异常。
   2. 这一步检查特权级的上限（门框）：处理器要检查当前特权级 CPL 和门描述符中所记录的选择子 对应的目标代码段 DPL，如果 CPL 权限小于目标代码段 DPL，即数值上 CPL>目标代码段 DPL，检查通 过。否则 CPL 若大于等于目标代码段 DPL，处理器将引发异常，也就是说，除了用返回指令从高特权级 返回，特权转移只能发生在由低向高。
3. 执行中断处理程序。

![image-20240813105449918](/home/abljiu/.config/Typora/typora-user-images/image-20240813105449918.png)

NT 位表示 Nest Task Flag，即任务嵌套标志位，也就是用来标记任务嵌套调用的情况。

1. 将旧任务 TSS 选择子写到了新任务 TSS 中的“上一个任务 TSS 的指针”字段中。
2. 将新任务标志寄存器 eflags 中的 NT 位置 1，表示新任务之所以能够执行，是因为有别的任务调 用了它。

当 CPU 执行 iret 时，它会去检查 NT 位的值，如果 NT 位为 1，这说明当前任务是被嵌套执行的，因此会从自己 TSS 中“上一个任务 TSS 的指针”字段中获取旧任务，然后去执行该任 务。如果 NT 位的值为 0，这表示当前是在中断处理环境下，于是就执行正常的中断退出流程。

#### 中断发生时的压栈

![image-20240813192657822](/home/abljiu/.config/Typora/typora-user-images/image-20240813192657822.png)

![image-20240813193330099](/home/abljiu/.config/Typora/typora-user-images/image-20240813193330099.png)

处理器进入中断执行完中断处理程序后，还要返回到被中断的进程，这是进入中断的逆过程。中断返 回是用 iret 指令实现的。Iret，即 interrupt ret，此指令专用于从中 断处理程序返回，假设在 32 位模式下，它从当前栈顶处依次弹出 32 位数据分别到寄存器 EIP、CS、EFLAGS。iret 指令并不清楚栈 中数据的正确性，它只负责把栈顶处往上的数据，每次 4 字节， 对号入座弹出到相关寄存器，所以在使用 iret 之前，一定要保证 栈顶往上的数据是正确的，且从栈顶往上的顺序是 EIP、CS、 EFLAGS，根据特权级是否有变化，还有 ESP、SS。

####  中断错误码 

错误码本 质上就是个描述符选择子，通过低 3 位属性来修饰 此选择子指向是哪个表中的哪个描述符

![image-20240813195816356](/home/abljiu/.config/Typora/typora-user-images/image-20240813195816356.png)

EXT 表示 EXTernal event，即外部事件，用来 指明中断源是否来自处理器外部，如果中断源是不 可屏蔽中断 NMI 或外部设备，EXT 为 1，否则为 0。

 IDT 表示选择子是否指向中断描述符表 IDT，IDT 位为 1，则表示此选择子指向中断描述符表，否则 指向全局描述符表 GDT 或局部描述符表 LDT。 

TI 和选择子中 TI 是一个意思，为 0 时用来指明选择子是从 GDT 中检索描述符，为 1 时是从 LDT 中 检索描述符。当然，只有在 IDT 位为 0 时 TI 位才有意义。 

选择子高 13 位索引就是选择子中用来在表中索引描述符用的下标。

### 可编程中断控制器 8259A

+ INT：8259A 选出优先级最高的中断请求后，发信号通知 CPU。 y INTA：INT Acknowledge，中断响应信号。位于 8259A 中的 INTA 接收来自 CPU 的 INTA 接口的 中断响应信号。 
+ IMR：Interrupt Mask Register，中断屏蔽寄存器，宽度是 8 位，用来屏蔽某个外设的中断。 
+ IRR：Interrupt Request Register，中断请求寄存器，宽度是 8 位。它的作用是接受经过 IMR 寄存器过 滤后的中断信号并锁存，此寄存器中全是等待处理的中断，“相当于”5259A 维护的未处理中断信号队列。 
+ PR：Priority Resolver，优先级仲裁器。当有多个中断同时发生，或当有新的中断请求进来时，将 它与当前正在处理的中断进行比较，找出优先级更高的中断。 
+ ISR：In-Service Register，中断服务寄存器，宽度是 8 位。当某个中断正在被处理时，保存在此寄存器中。

![image-20240813205703066](/home/abljiu/.config/Typora/typora-user-images/image-20240813205703066.png)

#### 8259A 的编程

![image-20240814094234345](/home/abljiu/.config/Typora/typora-user-images/image-20240814094234345.png)

ICW1 用来初始化 8259A 的连接方式和中断信号的触发方式。连接方式是指用单片工作，还是用多片级联工作，触发方式是指中断请求信号是电平触发，还是边沿触发。 

> 注意，ICW1 需要写入到主片的 0x20 端口和从片的 0xA0 端口，如图 7-13 所示。 

+ IC4 表示是否要写入 ICW4，这表示，并不是所有的 ICW 初始 化控制字都需要用到。IC4 为 1 时表示需要在后面写入 ICW4，为 0 则不需要。注意，x86 系统 IC4 必须为 1。 
+ SNGL 表示 single，若 SNGL 为 1，表示单片，若 SNGL 为 0，表 示级联（cascade）。这里说一下，若在级联模式下，这要涉及到主片（1 个）和从片（多个）用哪个 IRQ 接口互相连接的问题，所以当 SNGL 为 0 时，主片和从片也是需要 ICW3 的。 
+ ADI 表示 call address interval，用来设置 8085 的调用时间间隔，x86 不需要设置。 
+ LTIM 表示 level/edge triggered mode，用来设置中断检测方式，LTIM 为 0 表示边沿触发，LTIM 为 1 表示电平触发。 
+ 第 4 位的 1 是固定的，这是 ICW1 的标记。 
+ 第 5～7 位专用于 8085 处理器，x86 不需要，直接置为 0 即可。

![image-20240814094430618](/home/abljiu/.config/Typora/typora-user-images/image-20240814094430618.png)

ICW2 用来设置起始中断向量号，就是前面所说的硬件 IRQ 接口到逻辑中断向量号的映射。由于每个 8259A 芯片上的 IRQ 接口是顺序排列的，所以咱们这里的设置就是指定 IRQ0 映射到的中断向量号，其他 IRQ 接口对应的中断向量号会顺着自动排下去。

注意，ICW2 需要写入到主片的 0x21 端口和从片的 0xA1 端口

由于咱们只需要设置 IRQ0 的中断向量号，IRQ1～IRQ7 的中断向量号是 IRQ0 的顺延，所以，咱们只 负责填写高 5 位 T3～T7，ID0～ID2 这低 3 位不用咱们负责。由于咱们只填写高 5 位，所以任意数字都是 8 的倍数，这个数字表示的便是设定的起始中断向量号。这是有意设计的，低 3 位能表示 8 个中断向量号， 这由 8259A 根据 8 个 IRQ 接口的排列位次自行导入，IRQ0 的值是 000，IRQ1 的值是 001，IRQ2 的值便 是 010……以此类推，这样高 5 位加低 3 位，便表示了任意一个 IRQ 接口实际分配的中断向量号。

![image-20240814095509832](/home/abljiu/.config/Typora/typora-user-images/image-20240814095509832.png)

![image-20240814095519728](/home/abljiu/.config/Typora/typora-user-images/image-20240814095519728.png)





ICW3 仅在级联的方式下才需要（如果 ICW1 中的 SNGL 为 0），用来设置主片和从片用哪个 IRQ 接口互连。

对于主片，ICW3 中置 1 的那一位对应的 IRQ 接口用于连接从片，若为 0 则表示接外部设备。比如， 若主片 IRQ2 和 IRQ5 接有从片，则主片的 ICW3 为 00100100，

对于从片，要设置与主片 8259A 的连接方式，“不需要”指定用自己的哪个 IRQ 接口与主片连接，从片上专门用于级联主片的接口并不是 IRQ。在中断响应时，主片会发送与从片做级联的 IRQ 接口号，所有从片用自己的 ICW3 的低 3 位 和它对比，若一致则认为是发给自己的。比如主片用 IRQ2 接口连接从片 A，用 IRQ5 接口连接从片 B， 从片 A 的 ICW3 的值就应该设为 00000010，从片 B 的 ICW3 的值应该设为 00000101。所以，从片 ICW3 中的低 3 位 ID0～ID2 就够了，高 5 位不需要，为 0 即可。

![image-20240814100737188](/home/abljiu/.config/Typora/typora-user-images/image-20240814100737188.png)

ICW4 用来设置8259A 的工作模式

第 7～5 位未定义，直接置为 0 即可。

+ SFNM 表示特殊全嵌套模式（Special Fully Nested Mode），若 SFNM 为 0，则表示全嵌套模式，若 SFNM 为 1，则表示特殊全嵌套模式。 

+ BUF 表示本 8259A 芯片是否工作在缓冲模式。BUF 为 0，则工作非缓冲模式，BUF 为 1，则工作在缓冲模式。
+ 当多个 8259A 级联时，如果工作在缓冲模式下，M/S 用来规定本 8259A 是主片，还是从片。若 M/S 为 1，则表示则表示是主片，若 M/S 为 0，则表示是从片。若工作在非缓冲模式（BUF 为 0）下，M/S 无效。
+ AEOI 表示自动结束中断（Auto End Of Interrupt），8259A 在收到中断结束信号时才能继续处理下一个 中断，此项用来设置是否要让 8259A 自动把中断结束。若 AEOI 为 0，则表示非自动，即手动结束中断， 咱们可以在中断处理程序中或主函数中手动向 8259A 的主、从片发送 EOI 信号。这种“操作”类命令， 通过下面要介绍的 OCW 进行。若 AEOI 为 1，则表示自动结束中断。
+ μPM 表示微处理器类型（microprocessor），此项是为了兼容老处理器。若 μPM 为 0，则表示 8080 或 8085 处理器，若 μPM 为 1，则表示 x86 处理器。

![image-20240814103712404](/home/abljiu/.config/Typora/typora-user-images/image-20240814103712404.png)

OCW1 用来屏蔽连接在 8259A 上的外部设备的中断信号，实际上就是把 OCW1 写入了 IMR 寄存器。 这里的屏蔽是说是否把来自外部设备的中断信号转发给 CPU。由于外部设备的中断都是可屏蔽中断，所 以最终还是要受标志寄存器 eflags 中的 IF 位的管束，若 IF 为 0，可屏蔽中断全部被屏蔽，也就是说，在 IF 为 0 的情况下，即使 8259A 把外部设备的中断向量号发过来，CPU 也置之不理。

注意，OCW1 要写入主片的 0x21 或从片的 0xA1 端口

M0～M7 对应 8259A 的 IRQ0～IRQ7，某位为 1，对应的 IRQ 上的中断信号就被屏蔽了。否则某位为 0 的话，对应的 IRQ 中断信号则被放行

![image-20240814103835136](/home/abljiu/.config/Typora/typora-user-images/image-20240814103835136.png)

OCW2 用来设置中断结束方式和优先级模式。

注意，OCW2 要写入到主片的 0x20 及从片的 0xA0 端口。

OCW2 其中的一个作用就是发 EOI 信号结束中断。如果使 SL 为 1，可以用 OCW2 的低 3 位（L2～L0）来 指定位于 ISR 寄存器中的哪一个中断被终止，也就是结束来自哪个 IRQ 接口的中断信号。如果 SL 位为 0，L2～ L0 便不起作用了，8259A 会自动将正在处理的中断结束，也就是把 ISR 寄存器中优先级最高的位清 0。

OCW2 另一个作用就是设置优先级控制方式，这是用 R 位（第 7 位）来设置的。如果 R 为 0，表示固定优先级方式，即 IRQ 接口号越低，优先级越高。 如果 R 为 1，表明用循环优先级方式，这样优先级会在 0～7 内循环。如果 SL 为 0，初始的优先级次 序为 IR0>IR1>IR2>IR3>IR4>IR5>IR6>IR7。另外，还可以打开 SL 开关，使 SL 为 1，再通过 L2～L1 指定最低优先级 是哪个 IRQ 接口。

+ R,Rotation，表示是否按照循环方式设置中断优先级。R 为 1 表示优先级自动循环，R 为 0 表示不自 动循环，采用固定优先级方式。
+ SL,Specific Level，表示是否指定优先等级。等级是用低 3 位来指定的。此处的 SL 只是开启低 3 位的 开关，所以 SL 也表示低 3 位的 L2～L0 是否有效。SL 为 1 表示有效，SL 为 0 表示无效。
+ EOI，End Of Interrupt，为中断结束命令位。令 EOI 为 1，则会令 ISR 寄存器中的相应位清 0，也就是 将当前处理的中断清掉，表示处理结束。向 8259A 主动发送 EOI 是手工结束中断的做法，所以，使用此 命令有个前提，就是 ICW4 中的 AEOI 位为 0，非自动结束中断时才用。
+ 第 4～3 位的 00 是 OCW2 的标识。
+ L2～L0 用来确定优先级的编码，这里分两种，一种用于 EOI 时，表示被中断的优先级别，另一种用于优先级循环时，指定起始最低的优先级别。

![image-20240814105522890](/home/abljiu/.config/Typora/typora-user-images/image-20240814105522890.png)

![image-20240814105543444](/home/abljiu/.config/Typora/typora-user-images/image-20240814105543444.png)



OCW3 用来设定特殊屏蔽方式及查询方式

第 6 位的 ESMM（Enable Special Mask Mode）和第 5 位的 SMM（Special Mask Mode）是组合在一起 用的，用来启用或禁用特殊屏蔽模式。ESMM 是特殊屏蔽模式允许位，是个开关。SMM 是特殊屏蔽模式位。 只有在启用特殊屏蔽模式时，特殊屏蔽模式才有效。也就是若 ESMM 为 0，则 SMM 无效。若 ESMM 为 1， SMM 为 0，表示未工作在特殊屏蔽模式。若 ESMM 和 SMM 都为 1，这才正式工作在特殊屏蔽模式下。

第 4～3 位的 01 是 OCW3 的标识，8259A 通过这两位判断是哪个控制字。

P,Poll command，查询命令，当 P 为 1 时，设置 8259A 为中断查询方式，这样就可以通过读取寄存器， 如 IRS，来查看当前的中断处理情况。

RR,Read Register，读取寄存器命令。它和 RIS 位是配合在一起使用的。当 RR 为 1 时才可以读取寄存器。

RIS,Read Interrupt register Select，读取中断寄存器选择位，顾名思义，就是用此位选择待读取的寄存 器。有点类似显卡寄存器中的索引的意思。若 RIS 为 1，表示选择 ISR 寄存器，若 RIS 为 0，表示选择 IRR 寄存器。这两个寄存器能否读取，前提是 RR 的值为 1。

+ ICW1 和 OCW2、OCW3 是用偶地址端口 0x20（主片）或 0xA0（从片）写入。

+ ICW2～ICW4 和 OCW1 是用奇地址端口 0x21（主片）或 0xA1（从片）写入。

对于 8259A 的初始化必须最先完成，步骤是：

+ 无论 8259A 是否级联，ICW1 和 ICW2 是必须要有的，并且要顺序写入。
+ 只有当 ICW1 中的 SNGL 位为 0 时，这表示级联，级联就需要设置主片和从片，这才需要在主片 和从片中各写入 ICW3。注意，ICW3 的格式在主片和从片中是不同的
+ 只能当 ICW1 中的 IC4 为 1 时，才需要写入 ICW4。不过，x86 系统 IC4 必须为 1。

### 编写中断处理程序

#### 从最简单的中断处理程序开始

![image-20240814110254470](/home/abljiu/.config/Typora/typora-user-images/image-20240814110254470.png)

#### 内存池规划 

为什么要将位图地址选在低端 1MB 以下

> 一 般的内存管理系统所管理的是那些空闲的内存，即已被使用的内存是不在内存池中的，“已使用的内存” 当然包括内存管理相关数据结构所占的内存，位图就是用于管理内存的数据结构，这也是位图地址选为 0xc009a000（0x9a000）的原因，此地址位于低端 1MB 之内，这里面的内存几乎都被占用了，因此我们就 不用考虑它占用的内存了。

​       